const MyTest = artifacts.require("Test");

contract('MyTest', (accounts) => {
  it('code test', async () => {
    const testInstance = await MyTest.deployed();
    await testInstance.generateBytes32("0x123456789abcd");
    let a = await testInstance.bytes32v();
    let b = await testInstance.decodeBytes32(a);
    let context = "0x0000000000000000000000070707070707070707070707070707070000001010";
    let observers = "0x0001020304000000000000000000000000000000000000000000000000000000";
    let dataList = ["0x000000000000000000000000000000000000000000000000000000000000007b",
    "0x00000000000000000000000000000000000000000000000000000000000000f5",
    "0x0000000000000000000000000000000000000000000000000000000000c99dc3",
    "0x000000000000000000000000000000000000000000000000000070100b76d385",
    "0x0000000000000000000000000000000000000000000000000000000000000001"];
    await testInstance.generate(context, observers, dataList);
    let report = await testInstance.report();
    let myCode = "0x0000000000000000000000070707070707070707070707070707070000001010000102030400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000f50000000000000000000000000000000000000000000000000000000000c99dc3000000000000000000000000000000000000000000000000000070100b76d3850000000000000000000000000000000000000000000000000000000000000001";
    assert.equal(myCode, report, "invalid format");
    let reportStr = myCode;
    const messageHash = web3.utils.sha3(reportStr);
    let userOne = web3.eth.accounts.create(web3.utils.randomHex(32));
    let signature = web3.eth.accounts.sign(messageHash, userOne.privateKey);
    await testInstance.verifySign3(report, signature.r, signature.s, signature.v);
    let hash = await testInstance.reportHash();
    let signer = await testInstance.publicKey();
    assert.equal(signer, userOne.address, "invalid sign");
  });

  it('sha test', async () => {
    const testInstance = await MyTest.deployed();
    let context = "0x0000000000000000000000070707070707070707070707070707070000001010";
    let observers = "0x0001020304000000000000000000000000000000000000000000000000000000";
    let dataList = ["0x000000000000000000000000000000000000000000000000000000000000007b",
    "0x00000000000000000000000000000000000000000000000000000000000000f5",
    "0x0000000000000000000000000000000000000000000000000000000000c99dc3",
    "0x000000000000000000000000000000000000000000000000000070100b76d385",
    "0x0000000000000000000000000000000000000000000000000000000000000001"];
    await testInstance.generate(context, observers, dataList);
    let report = await testInstance.report();
    let sha = await testInstance.calSha256(report);
    let hashFromAelf = "0x90c8905400249e6c663ca108c82090230601e91f0d2577c67d6c428dbe175f39";
    assert.equal(sha, hashFromAelf, "invalid hash op");
  });

  it('decode report', async () => {
    const testInstance = await MyTest.deployed();
    let encodeData = "0x00000000000007070707070707070707070707070707000000000000000a030700040a00000000000000000000000000000000000000000000000000000000000a05617364617300000000000000000000000000000000000000000000000000";
    let decodeData = await testInstance.decodeReport2(encodeData);
    assert.equal(decodeData.roundId, 10, "invalid round id");
    assert.equal(decodeData.observerCount, 3, "invalid observerCount");
    assert.equal(decodeData.validBytesCount, 7, "invalid validBytesCount");
    assert.equal(decodeData.observation, "0x0a05617364617300000000000000000000000000000000000000000000000000", "invalid observation");
    assert.equal(decodeData.rawObservers, "0x00040a0000000000000000000000000000000000000000000000000000000000", "invalid observation");

    encodeData = "0x00000000000007070707070707070707070707070707000000000000000a033500040a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000020a33617364617361736461736464e890a8e58da1e698afe59296e595a1e590a7e698afe59296e595a1e590a7e5bab7e5b888e582850000000000000000000000";
    decodeData = await testInstance.decodeReport3(encodeData);
    assert.equal(decodeData.dataCount, 53, "report 3 decode invalid data count");
    assert.equal(decodeData.data[0], "0x0a33617364617361736461736464e890a8e58da1e698afe59296e595a1e590a7", "report 3 decode invalid data");
    assert.equal(decodeData.data[1], "0xe698afe59296e595a1e590a7e5bab7e5b888e582850000000000000000000000", "report 3 decode invalid data");
  });

  it('fee test', async () => {
    const testInstance = await MyTest.deployed();
    let gweiAmount = await testInstance.getGweiAmount();
    assert.equal(gweiAmount.toString(), 1000000000);
    let gasPrice = await testInstance.getGasPrice();
    console.log(gasPrice.toString());
  });
});

